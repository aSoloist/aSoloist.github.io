<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ubuntu 将80端口请求转发到8080]]></title>
    <url>%2F2017%2F12%2F31%2FUbuntu%20%E5%B0%8680%E7%AB%AF%E5%8F%A3%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%88%B08080%2F</url>
    <content type="text"><![CDATA[在Ubuntu部署了tomcat，一般会使用非root用户启动，但域名绑定时会直接访问80端口号。众所周知，在unix下，非root用户不能监听1024以上的端口号，这个tomcat服务器就没办法绑定在80端口下。所以这里需要使用linux的端口转发机制，把到80端口的服务请求都转到8080端口上。 安装 iptables-persistent12sudo apt-get updatesudo apt-get install iptables-persistent 添加 80 端口跳转到 8080 规则1sudo iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080 保存跳转规则1sudo iptables-save]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Tomcat</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次奇怪的debug]]></title>
    <url>%2F2017%2F12%2F31%2F%E4%B8%80%E6%AC%A1%E5%A5%87%E6%80%AA%E7%9A%84debug%2F</url>
    <content type="text"><![CDATA[前言第一次在服务器Tomcat上用war包部署项目，但是在部署新的war包时出现了一个奇怪的bug，访问页面时，第一次打开会显示404页面，然后按F5刷新则会显示正常页面。 解决最初先清除了浏览器缓存，重新访问，并没有解决。 然后尝试了重新部署，仍没有解决问题。 ps:我部署的方式极其简单粗暴 idea导出war包，用xshell传到服务器 stop Tomcat 删除Tomcat的webapps目录下之前的war包和文件夹 将war包拷贝到webapps目录下 start Tomcat 后来查到一个办法，删除tomcat中work/Catalina目录下项目同名文件 不过我在目录下没找到同名文件，只有一个localhost（可能是我server.xml文件配置问题？）文件夹，删除之后，再访问，正常显示。]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>war部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 简单语法]]></title>
    <url>%2F2017%2F12%2F30%2FMarkdown%20%E7%AE%80%E5%8D%95%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown是一种极简的『标记语言』，将文本转为HTML，本文介绍Markdown基本语法，内容很少，一行语法一行示例。 强调星号与下划线都可以，单是斜体，双是粗体，符号可跨行，符号可加空格 12345**一个人来到田纳西**__毫无疑问__*我做的馅饼是全天下*_最好吃的_ 一个人来到田纳西 毫无疑问 我做的馅饼是全天下 最好吃的 分割线三个或更多-_*，必须单独一行，可含空格 1___ 引用翻译成html就是&lt;blockquote&gt;&lt;/blockquote&gt;，符号后的空格可不要 1&gt;引用 引用 内层符号前的空格必须要 12&gt;引用 &gt;&gt;引用 引用 引用 无序列表 符号之后的空格不能少，-+*效果一样，但不能混合使用，因混合是嵌套列表，内容可超长 12- 无序列表- 无序列表：我很长。我也很长！那比一比啊？比就比！我有这么长，你有我长吗？我有这么这么长！好吧，你赢了！ 无序列表 无序列表：我很长。我也很长！那比一比啊？比就比！我有这么长，你有我长吗？我有这么这么长！好吧，你赢了！ 有序列表数字不能省略但可无序，点号之后的空格不能少 12341. 有序列表2. 有序列表3. 有序列表8. 有序列表 有序列表 有序列表 有序列表 有序列表 嵌套列表-+*可循环使用，但符号之后的空格不能少，符号之前的空格至少为两个 123456- 嵌套列表 + 嵌套列表 + 嵌套列表 - 嵌套列表 * 嵌套列表- 嵌套列表 嵌套列表 嵌套列表 嵌套列表 嵌套列表 嵌套列表 嵌套列表 文字超链：Inline方式1[百度](http://www.baidu.com "百度") 百度 图片超链多个感叹号，Tooltips可省略，要设置大小只能借助HTML标记 1![GitHub Mark](http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png "GitHub Mark") 索引超链：Reference方式索引，[]内可以是任意字符 123![GitHub Octocat][1][1]:http://github.global.ssl.fastly.net/images/modules/logos_page/Octocat.png 自动链接1&lt;http://baidu.com&gt; http://baidu.com 注释1&lt;!-- 注释 --&gt; 其他文本中可直接用html标签，但是要前后加上空行。]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下常用指令]]></title>
    <url>%2F2017%2F12%2F30%2FUbuntu%E4%B8%8B%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[前言最近租了个服务器，用的是ubuntu17.04版本系统，所以搜集了一部分常用的指令，方便以后查阅。 基本命令常用命令帮助–help简单的帮助 help command 详细的帮助 man command 最详细的帮助 ls 命令（显示当前目录文件）-a 显示全部文件与文件夹，包括隐藏的文件或文件夹 -l 显示详细的文件信息，包括权限，用户，用户组等 -h 将文件大小以方便阅读的形式表示出来，配合-l参数使用，常有奇效 cd 进入其他目录cd /etc/ 从绝对路径进入etc文件夹 cd etc/ 从当前目录进入etc文件夹 cd .. 返回当前目录的上一级目录 cd - 返回上一次所在的目录 cd 或 cd ~ 返回属主目录 tab键 命令补全tab键常用于在你输入了命令的前几个单词时，按下tab键进行补全，如果有多个前面部分相同的命令，则按两次tab键 alias 别名alias ubuntu=”ls” 用于为一个命令取别名，当你输入ubuntu时等价输入了ls命令 apt-get 下载最常用的指令，用于从软件源获取需要的软件 常用参数： update 与你的软件源（在/etc/apt/sources.list中列出）更新软件包列表，换源后需要执行 upgrade 根据update得到的源软件库与本地已经安装的对比，如果需要升级就全部升级 install 安装软件包，可以使用tab键补全软件包的名字 remove 卸载软件包 purge 卸载软件包，同时删除该软件的配置文件 source 从源里下载软件包的源码到当前目录并解压（除非指定-download-only参数） check 用来（自动）修复已安装软件包之间的依赖关系 clean 清除/var/cache/apt/archives/包括其子目录partial/下的所有软件包缓存 autoclean 删除旧版本的软件包缓存 download 下载软件包的二进制包到当前目录 more、less 分页显示文本文件内容head、tail 显示文件头、尾内容| 管道符 连接多个命令将一个命令的标准输出作为另一个命令的标准输入。也就是把几个命令组合起来使用，后一个命令除以前一个命令的结果。 例：grep -r “close” /home/* | more 在home目录下所有文件中查找，包括close的文件，并分页输出。 grep 字符串 在文本文件中查找某个字符串sudo 管理员权限sudo 我们主要用来临时提升权限，主要用以管理员(超级用户)的权限来运行命令，当需要修改当前登录用户力所不能及的文件/目录时需要用sudo 文件操作find 起始目录 -name 查找的文件或目录mkdir 目录名 创建一个目录-p 如果给出的路径中父目录不存在,则同时创建父目录 touch 文件名 .. 创建一个或多个文件rmdir 空目录名 删除一个空目录等同 rm -f rm 文件名 .. 删除一个或多个文件最常用参数: -f 不提示不存在的文件,直接跳过 -i 每个删除动作都提示 -I 删除多个文件(多于3个时)或者递归式删除(对于非空目录)提示一次 -r和-R 递归式删除该目录下的一切东东 -v 显示每个文件的删除动作(个人总是推荐使用此参数,明白你在做什么) 注意：慎用 rm -rf 非空目录名 删除一个非空目录下的一切 mv 源文件或目录 目标文件或目录根据mv命令中的第二个参数类型（是目标文件还是目标目录），mv命令将文件重命名或将其移至一个新的目录中。当第二个参数类型是文件时，mv命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录中。 最常用参数: -b 为每个已经存在的目的文件做个备份(防止覆盖) -f 不提示是否覆盖已经存在的目的文件 -i 与-f参数相反 -u 仅当源文件比目的文件更新或者目的文件不存在时候才移动 -v 显示移动文件的进度(个人总是推荐使用此参数,明白你在做什么) cat 文件名 ..把(一个或多个)文件内容(连接)显示到标准输出，当文本文件很小，而且你只是想看下，并不打算用gedit或者vim之类编辑器编辑的时候，可以使用。 find 路经 -name“字符串”查找路经所在范围内满足字符串匹配的文件和目录 最常用参数: -v 列出当前正在执行的步骤 -R 递归式,即改变非空目录下的一切为指定权限 cp 文件名或目录名 拷贝文件或目录最常用参数： -b 为每个已经存在的目的文件作个备份 -d 遇到软链接时不拷贝软链接所指向的文件;拷贝时保留links属性(链接数) -p 保留文件的访问权限,所有者,和时间戳 -R和-r 递归式拷贝(cp过程遇到非空目录才有效),即拷贝目录,子目录,子目录的子目录….. -a 作用同-dpR -s 并不真的做拷贝,而只是为每个文件作软链接(符号链接) -u 仅当源文件比目的文件更新或者目的文件不存在时候才拷贝 ln 源文件或目录 目标文件或目录 为文件建立连接linux的链接分为两种:硬链接和软链接，ln默认建立硬链接，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统 注意： ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化 最常用参数: -s 建立软链接(符号链接,可以理解为win下的快捷方式) -f 如果要建立的链接名已经存在,则删除之 -b 删除，覆盖以前建立的链接 -v 显示详细的处理过程 tar 打包与解包和ps命令一样,tar一般不用单个参数,而是多个参数的组合,记住参数x是解压(extract),c是创建包(create)即可 最常用参数: -xvf 详细列出解包的步骤 -cvf 详细列出打包的步骤 -j 用来说明这是个tar.bz2包,例如tar -xjvf myfile.tar.bz2 -t 列出包中的文件列表 打包时常追加的参数: -r 追加到压缩包中 -u 只把比包中更新的文件追加进去 -h 不把符号链接添加到包中,而是添加此符号链接指向的文件 用户管理/etc/passwd 存储用户账号/etc/group 存储组账号/etc/shadow 存储用户账号的密码/etc/gshadow 存储用户组账号的密码/etc/profile 系统环境变量bash_profile 用户环境变量.bashrc 用户环境变量su user 切换用户，加载配置文件.bashrcsu - user 切换用户，加载配置文件/etc/profile ，加载bash_profileuseradd 创建一个新的用户groupadd 组名 创建一个新的组passwd 用户名 为用户创建密码最常用参数： -d 用户名 删除用户密码也能登陆 -S 用户名 查询用户状态 usermod -l 新用户名 老用户名 为用户改名userdel –r 用户名 删除用户一切chown [-R] owner[:group] {File|Directory} 更改文件的用户及用户组chown root:root filename 如果需要将某一目录下的所有文件都改变其拥有者，可以使用-R参数 chgrp [group] {File|Directory} 更改文件所属组群chgrp root filename chgrp 权限管理三种基本权限 R 读 数值表示为4 W 写 数值表示为2 X 可执行 数值表示为1 例如： -rw-rw-r–一共十个字符，分成四段。 第一个字符“-”表示普通文件；这个位置还可能会出现“l”链接；“d”表示目录 第二三四个字符“rw-”表示当前所属用户的权限，所以用数值表示为4+2=6 第五六七个字符“rw-”表示当前所属组的权限，所以用数值表示为4+2=6 第八九十个字符“r–”表示其他用户权限，所以用数值表示为2 更改权限sudo chmod [u所属用户 g所属组 o其他用户 a所有用户] [+增加权限 -减少权限] [r w x] 目录名 例如：有一个文件filename，权限为“-rw-r—-x”，将权限值改为“-rwxrw-r-x”，用数值表示为765 sudo chmod u+x g+w o+r filename 上面的例子可以用数值表示 sudo chmod 765 filename 系统管理ps，top 列出当前命令的执行状态ps为静态，top为动态(top时’q’退出) 最常用参数(ps多用参数集合,而不是单个参数,并且配合grep使用): -ef 以标准语法列出当前所有进程状态,例如ps -ef | grep eva 列出eva的进程状态 aux 以BSD语法列出 -ejH 列出进程树 -eLf 同时列出线程状态 kill 进程号(PID) 杀死一个进程kill -9 进程号 强制杀死一个进程stat 显示指定文件的详细信息，比ls更详细who 显示在线登陆用户whoami 显示当前操作用户hostname 显示主机名uname 显示系统信息du 查看目录大小 du -h /home带有单位显示目录信息df 查看磁盘大小 df -h 带有单位显示磁盘信息ifconfig 查看网络情况ping 测试网络连通netstat 显示网络状态信息常用参数 -a (all)显示所有选项，默认不显示LISTEN相关 -t (tcp)仅显示tcp相关选项 -u (udp)仅显示udp相关选项 -n 拒绝显示别名，能显示数字的全部转化成数字。 -l 仅列出有在 Listen (监听) 的服務状态 -p 显示建立相关链接的程序名 -r 显示路由信息，路由表 -e 显示扩展信息，例如uid等 -s 按各个协议进行统计 -c 每隔一个固定时间，执行该netstat命令。 注意： LISTEN和LISTENING的状态只有用-a或者-l才能看到 man 功能很多，简单的可以查看命令帮助，如：man lsufw 防火墙常用参数： enable 启动防火墙 status 查看防火墙状态 allow 端口号或服务名 开放指定端口号 allow 22/tcp 只打开使用tcp/ip协议的22端口 disable 关闭防火墙 allow from 192.168.254.254 允许某特定IP delete allow 删除已添加的规则 clear 清屏]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>常用命令</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 数据类型]]></title>
    <url>%2F2017%2F11%2F18%2Fjava%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Java 的数据类型分为基本数据类型和引用数据类型。 基本数据类型基本数据类型有四类八种，分别是： byte：Java中最小的数据类型，在内存中占8位(bit)，即1个字节，取值范围-128~127，默认值0、 short：短整型，在内存中占16位，即2个字节，取值范围-32768~32717，默认值0、 int：整型，用于存储整数，在内在中占32位，即4个字节，取值范围-2147483648~2147483647，默认值0、 long：长整型，在内存中占64位，即8个字节-2^63~2^63-1，默认值0L； float：浮点型，在内存中占32位，即4个字节，用于存储带小数点的数字（与double的区别在于float类型有效小数点只有6~7位），默认值0、 double：双精度浮点型，用于存储带有小数点的数字，在内存中占64位，即8个字节，默认值0； boolean：布尔类型，占1个字节，用于判断真或假（仅有两个值，即true、false），默认值false； char：字符型，用于存储单个字符，占16位，即2个字节，取值范围0~65535，默认值为空。 这种类型通过如 int a = 3 的形式定义，称为自动变量。值得注意的是，自动变量存的是字面值，不是类的引用，这里的 a 是一个指向 int 类型的引用，指向3这个字面值。这些字面值大小可知，生存期可知，因此会保存在栈中。 另外，栈有一个很重要的特殊性，即数据可以共享。如果我们同时定义12int a = 3; int b = 3; 编译器先处理 int a = 3 ；会在栈中创建一个变量a的引用，然后查找有无字面值为3的地址，如果没有，则开辟一个存放3字面值的地址，然后将a指向3的地址。然后处理 int b = 3 ；创建b的引用后，由于栈中已经有3的字面值，便将b直接指向3的地址。因此，a与b同时指向3。 但是要注意，通过引用修改字面值不会导致另一个指向此字面值的引用的值改变，在字面值被修改时，编译器会重新搜索栈中是否存在被修改后的字面值，如果不存在，则开辟一片空间存放新字面值的地址，如果存在，则直接将引用指向这个地址。 引用数据类型除基本数据类型之外的数据类型都是引用数据类型，其中 String 类是特殊的引用数据类型，这些类型的数据全部存放在堆中，Java 通过 new 关键字来显式告诉编译器，在运行时根据需要动态创建，比较灵活，但是会占用更多的时间。 1Object o = new Object(); 引用数据类型（除String）在创建时可以同时创建一个引用变量，该变量是基本数据类型，存储在栈中，指向引用数据类型在堆中的地址。如果通过一个引用变量修改引用数据类型，则其他指向这个对象的引用也会即刻反映出这些改变。 在方法中，调用时传入的实际参数，如果是基本数据类型，则会传入字面值，而如果是引用数据类型，则传入的是该对象的地址。因此，在被调用方法中对引用数据类型进行操作，调用方法中的引用变量所对应的该对象也会相应变化。 String 类String 类是一种特殊的引用数据类型。可以使用 String str = new String(&quot;asd&quot;); 的方式来创建，也可以使用 String str = &quot;asd&quot;; 的方式来创建。一个字符串对象创建后他的值不能改变，如果改变字符串的值，编译器将会创建一个新的字符串对象，然后把地址指向新地址。 常量池(constant pool)指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。它包括了关于类、方法、接口等中的常量，也包括字符串常量。因此，对于 String str = &quot;asd&quot;; ，将会保存在常量池中。而对于 String str = new String(&quot;asd&quot;); ，编译器将会创建一个字符串对象，并把 str指向该地址。 12345String s1 = "";String s2 = new String("");System.out.println(s1);System.out.println(s2); 将会打印 12null 1234567String s0 = "asdf"; String s1 = "asdf"; String s2 = "as" + "df"; System.out.println(s0 == s1); System.out.println(s0 == s2); 将会打印 12truetrue 因为这些字符串在编译时就被确定了，其中 String s2 = &quot;as&quot; + &quot;df&quot;; 由多个字符串常量连接而成，因此在编译时就被解析为一个字符串常量，因此结果为true。 1234567String s0 = "asdf";String s1 = new String("asdf");String s2 = "as" + new String("df");System.out.println(s0 == s1);System.out.println(s0 == s2);System.out.println(s1 == s2); 结果为123false false false 其中 s0 是在编译时常量池中的引用， s1 是在运行时创建的对象， s2 因为在编译时无法确定 new String(“df”)，所以也是在运行时创建的对象，其地址与 s1 不同。因此结果为false。 如果想要比较字符串之间的值，则应该使用 equals() 方法。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 堆和栈]]></title>
    <url>%2F2017%2F11%2F17%2Fjava%20%E5%A0%86%E5%92%8C%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈和堆在 Java 中是用来在内存中存放数据的地方，与 C/C++ 不同， Java 自动管理栈和堆。 栈的存取速度比堆要快，仅次于直接位于 CPU 中的寄存器。但是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。堆可以动态的分配内存大小，生存期也可以不先告诉编译器，但是存取速度较慢。 内存Java 的内存分为两种，堆内存和栈内存。 区别栈内存用于存放一些基本类型的变量和对象的引用变量。当在一段代码块中定义一个变量时， Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java 会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。 堆内存用于存放由 new 创建的对象和数组。在堆中分配的内存，由 Java 虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，在栈中的这个特殊的变量就变成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的一个别名，或者代号，是一个普通变量，在栈中分配内存，当程序运行到作用域外时释放。 数组和对象本身在堆中分配，在程序运行到使用 new 产生数组或对象的语句所在代码块之外，所占用的内存也不会释放。数组和对象在没有引用变量指向它的时候，将会变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间由垃圾回收器释放。这是 Java 占内存的主要原因。 栈中的变量指向堆中的变量，可以看作是 Java 的指针。 分配策略按照编译原理观点，程序运行时的内存分配有三种策略：静态、栈式、堆式。 静态储存分配指在编译时就能确定每个数据目标在运行时刻的储存空间需求，因此在编译时就可以给他们分配固定的内存空间，这种分配策略要求程序代码中不能有可变数据结构，也不允许有嵌套或者递归的结构出现，因为他们会导致编译程序无法准确计算储存空间需求。 栈式存储分配也可称为动态存储分配，是由一个类似于堆栈的运行栈来实现的。和静态存储分配相反，在栈式存储方案中，程序对数据区的需求在编译时是完全未知的，只有到运行的时候才能够知道，但是规定在运行中进入一个程序模块时，必须知道该程序模块所需的数据区大小才能够为其分配内存.和我们在数据结构所熟知的栈一样，栈式存储分配按照先进后出的原则进行分配。 栈式储存分配要求在过程的入口处必须知道所有的存储需求，而堆式分配则专门负责在编译时或运行时模块入口处都无法确定储存需求的数据结构的内存分配，比如：可变长度串和对象实例，堆由大片的可利用块或空闲块组成，堆中的内存可以按照任意顺序分配和释放。 区别从栈和堆的功能和作用来通俗的比较，堆主要用来存放对象，栈主要用来执行程序。这种不同主要是由于堆和栈的特点决定的： 在 Java 中，所有的方法调用都是通过栈来进行的，所有的局部变量，形式参数都是从栈中分配内存空间。实际上也不是什么分配，只是从栈顶向上用就行。需要注意的是，在分配的时候，比如为一个即将要调用的程序模块分配数据区时，应事先知道这个数据区的大小，也就说是虽然分配是在程序运行时进行的，但是分配的大小多少是确定的，不变的，而这个“大小多少”是在编译时确定的，不是在运行时。 堆是应用程序在运行的时候请求操作系统分配给自己内存，由于从操作系统管理的内存分配，所以在分配和销毁时都要占用时间，因此用堆的效率非常低。但是堆的优点在于，编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间，因此，用堆保存数据时会得到更大的灵活性。事实上，面向对象的多态性，堆内存分配是必不可少的，因为多态变量所需的存储空间只有在运行时创建了对象之后才能确定。 JVM 中的堆和栈JVM 是基于栈的虚拟机。 JVM 为每个新创建的线程都分配一个栈.也就是说，对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作：以帧为单位的压栈和出栈操作。 我们知道，某个线程正在执行的方法称为此线程的当前方法，当前方法使用的帧称为当前帧。当线程激活一个 Java 方法， JVM 就会在线程的 Java 堆栈里新压入一个帧，这个帧自然成为了当前帧。在此方法执行期间，这个帧将用来保存参数，局部变量，中间计算过程和其他数据，这个帧在这里和编译原理中的活动纪录的概念是差不多的。 从 Java 的这种分配机制来看，栈又可以这样理解：栈是 JVM 在建立某个进程时或者线程为这个线程建立的存储区域，该区域具有先进后出的特性。 每一个 Java 应用都唯一对应一个 JVM 实例，每一个实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或数组都放在这个堆中，并由应用所有的线程共享。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle 项目中文乱码的解决]]></title>
    <url>%2F2017%2F09%2F27%2FGradle%20%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[前言最近使用 Gradle 构建项目，项目里需要自定义异常，结果发现异常信息乱码。百度了一堆教程也没解决，最后查看 class 文件发现是编译过程中造成的乱码。 在官方文档中发现， Gradle 会根据操作系统选择编码，Windows 中文操作系统的默认编码是GBK，而项目使用的编码格式是UTF-8，最终 Gradle 将UTF-8编码识别为GBK编码，导致了乱码问题。 解决办法在 build.gradle 文件中添加 123tasks.withType(JavaCompile) &#123; options.encoding = "UTF-8" &#125; 这样 Gradle 会将文件识别为UTF-8编码。 其他上面的解决办法需要每个项目都插入一段，有点麻烦，不过还是有其他更简便的办法。就是在 Windows 下新建 GRADLE_OPTS 环境变量，值为 -Dfile.encoding=utf-8。这样在终端中使用的 Gradle 命令便可以识别UTF-8编码格式。 如果是 IDE 进行 Gradle 操作，那么还需要设置IDE的参数。因为我使用的是 idea，这里只介绍 idea 的解决办法。打开 File-&gt;Settings-&gt;Build,Execution,Deployment-&gt;Build Tools-&gt;Gradle，在 Gradle Vm Options 中添加 -Dfile.encoding=utf-8。]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea 常用快捷键及插件]]></title>
    <url>%2F2017%2F09%2F27%2Fidea%20%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8A%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[记录下 idea 常用的快捷键，便于以后使用。 快捷键生成代码常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码 要输入for(User user : users)只需输入user.for+Tab 要输入Date birthday = user.getBirthday();只需输入user.getBirthday().var+Tab即可。代码标签输入完成后，按Tab，生成代码 Ctrl+Alt+O 优化导入的类和包 Alt+Insert 生成代码(如get,set方法,构造函数等)或者右键（Generate） fori/sout/psvm + Tab Ctrl+Alt+T 生成try catch 或者 Alt+Enter Ctrl+Alt+T 把选中的代码放在 TRY{} IF{} ELSE{} 里 Ctrl + O 重写方法 Ctrl + I 实现方法 Ctrl+Shift+U 大小写转化 Alt+回车 导入包,自动修正 Ctrl+J 自动代码 Ctrl+Shift+J，整合两行为一行 Ctrl+空格 代码提示 Ctrl+Shift+SPACE 自动补全代码 Ctrl+Alt+L 格式化代码 Ctrl+Alt+I 自动缩进 Ctrl+Alt+O 优化导入的类和包 Alt+Insert 生成代码(如GET,SET方法,构造函数等) Ctrl+E 最近更改的代码 Ctrl+Alt+SPACE 类名或接口名提示 Ctrl+P 方法参数提示 Ctrl+Q 可以看到当前方法的声明 Shift+F6 重构-重命名 (包、类、方法、变量、甚至注释等) Ctrl+Alt+V 提取变量 查询Ctrl+Shift+Backspace 可以跳转到上次编辑的地 Ctrl+Alt+left/right 前后导航编辑过的地方 Alt+7 靠左窗口显示当前文件的结构 Ctrl+F12 浮动显示当前文件的结构 Alt+F7 找到你的函数或者变量或者类的所有引用到的地方 Ctrl+Alt+F7 找到你的函数或者变量或者类的所有引用到的地方 Ctrl+Shift+Alt+N 查找类中的方法或变量 双击Shift 在项目的所有目录查找文件 Ctrl+N 查找类 Ctrl+Shift+N 查找文件 Ctrl+G 定位行 Ctrl+F 在当前窗口查找文本 Ctrl+Shift+F 在指定窗口查找文本 Ctrl+R 在当前窗口替换文本 Ctrl+Shift+R 在指定窗口替换文本 Alt+Shift+C 查找修改的文件 Ctrl+E 最近打开的文件 F3 向下查找关键字出现位置 Shift+F3 向上一个关键字出现位置 选中文本，按Alt+F3 ，高亮相同文本，F3逐个往下查找相同文本 F4 查找变量来源 Ctrl+Shift+O 弹出显示查找内容 Ctrl+W 选中代码，连续按会有其他效果 F2 或Shift+F2 高亮错误或警告快速定位 Ctrl+Up/Down 光标跳转到第一行或最后一行下 Ctrl+B 快速打开光标处的类或方法 Ctrl+Alt+B 找所有的子类 Ctrl+Shift+B 找变量的类 Ctrl+Shift+上下键 上下移动代码 Ctrl+Alt+ left/right 返回至上次浏览的位置 Ctrl+X 删除行 Ctrl+D 复制行 Ctrl+/ 或 Ctrl+Shift+/ 注释（// 或者/…/ ） Ctrl+H 显示类结构图 Ctrl+Q 显示注释文档 Alt+F1 查找代码所在位置 Alt+1 快速打开或隐藏工程面板 Alt+ left/right 切换代码视图 Alt+ ↑/↓ 在方法间快速移动定位 Alt+6 查找TODO 调试Alt+F8 debug时选中查看值 Alt+Shift+F9 选择 Debug Alt+Shift+F10 选择 Run Ctrl+Shift+F9 编译 Ctrl+Shift+F8 查看断点 F7 步入 Shift+F7 智能步入 Alt+Shift+F7 强制步入 F8 步过 Shift+F8 步出 Alt+Shift+F8 强制步过 Alt+F9 运行至光标处 Ctrl+Alt+F9 强制运行至光标处 F9 恢复程序 Alt+F10 定位到断点 重构Ctrl+Alt+Shift+T 弹出重构菜单 Shift+F6 重命名 F6 移动 F5 复制 Alt+Delete 安全删除 Ctrl+Alt+N 内联 其他Shift+Enter 另起一行 Ctrl+Z 倒退(撤销) Ctrl+Shift+Z 向前(取消撤销) Ctrl+Alt+F12 资源管理器打开文件夹 Alt+F1 查找文件所在目录位置 Shift+Alt+Insert 竖编辑模式 Ctrl+F4 关闭当前窗口 Ctrl+Alt+V 可以引入变量。例如：new String(); 自动导入变量定义 Ctrl+~ 快速切换方案（界面外观、代码风格、快捷键映射等菜单） 插件插件的安装就不多介绍了，主要介绍下常用的插件 Background Image Plus个人很喜欢的一款插件，可以为idea添加背景，安装之后，在打开View选项，就可以看到Set Background Image选项了。 FindBugsFindBugs很多人都并不陌生，Eclipse中有插件可以帮助查找代码中隐藏的bug，IDEA中也有这款插件。 CheckStyle通过检查对代码编码格式，命名约定，Javadoc，类设计等方面进行代码规范和风格的检查，从而有效约束开发人员更好地遵循代码编写规范。 软件安装成功之后，首先要设置规则。可以通过Preferences—&gt;Other Settings —&gt;CheckStyles进行设置，可以直接将文件添加进来，然后就可以对具体的文件进行检查了。 GsonFormatJava开发中，经常有把json格式的内容转成Object的需求，GsonFormat这款插件可以实现该功能。 JrebelJRebel for IntelliJ是一款热部署插件。能够在开发过程中帮助开发者节约大量的部署等待时间，几乎所有的代码改动都不需要重启应用服务器，连Spring增加一个Bean都可以热部署。是一款收费插件，具体设置可以百度。 AceJumpAceJump其实是一款能够代替鼠标的软件，只要安装了这款插件，可以在代码中跳转到任意位置。按快捷键进入 AceJump 模式后（默认是 Ctrl+J），再按任一个字符，插件就会在屏幕中这个字符的所有出现位置都打上标签，你只要再按一下标签的字符，就能把光标移到该位置上。换言之，你要 移动光标时，眼睛一直看着目标位置就行了，根本不用管光标的当前位置。 Key promoterKey promoter这款插件适合新手使用。当你点击鼠标一个功能的时候，可以提示你这个功能快捷键是什么。]]></content>
      <categories>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo next主题添加背景]]></title>
    <url>%2F2017%2F09%2F17%2Fhexo%20next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E8%83%8C%E6%99%AF%2F</url>
    <content type="text"><![CDATA[之前使用hexo next主题时突然想添加背景，百度了一下但没有关于Mist主题的教程，于是自己摸索修改了一下，并在这里记录下来。 添加背景首先，找到根路径下的 themes/next/source/css/_custom/custom.styl 文件，添加 1234567body &#123; background : url(/images/你的背景图片名字) no-repeat; //width : 100%; //height : 100%; //设置容器占满屏幕 //background-size : 100% 100%; //设置图片占满容器 //background-attachment : fixed; //设置图片不随页面移动&#125; 并将背景图片添加到 themes/next/source/images 文件夹里 这里建议使用宽图。 效果 我们会发现导航栏显得不搭，这里在询问了朋友后的解决办法是透明化导航栏 透明化header虚化导航栏有两种方式： 1.在 themes/next/source/css/_common/components/header/header.styl 文件中修改 1.header &#123; background: $head-bg; opacity: 0.7&#125; 我们发现导航栏会变成这样 opacity 属性会将子容器也一并透明化，所以如果使用了next自带的搜索，将会失效无法使用 2.在 themes/next/source/css/_schemes/Mist/_header.styl 中修改 1.header &#123; background: rgba(245, 245, 245, 0.6); &#125; 效果为 因为子容器都有 background 属性，所以子容器不会受到父容器透明化的影响，而搜索功能也能正常使用 修改footer下拉博客会发现，footer 也因为设置了固定颜色而盖住了背景。 这个需要在 themes/next/source/css/_schemes/Mist/index.styl 文件中修改 123456.footer &#123; margin-top: 80px; padding: 10px 0; background-color: rgba(245, 245, 245, 0.6); color: $grey-dim;&#125; 如果想子容器也透明化的话，则在 themes/next/source/css/_common/components/footer/footer.styl 中修改，且不要修改 index.styl 文件 1234567.footer &#123; font-size: 14px; color: $grey-dark; opactiy: 0.7; img &#123; border: none; &#125;&#125; 结束至此，添加背景便完成了。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 反射]]></title>
    <url>%2F2017%2F09%2F12%2FJava%20%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[前言第一次接触反射是在学习 Spring 框架的时候，当看到 Spring 通过反射注入对象时感到十分有趣。所以这里系统的学习一下反射机制。 动态语言，是指程序在运行时可以改变其结构：新的函数可以被引进，已有的函数可以被删除等在结构上的变化。比如众所周知的ECMAScript(JavaScript)便是一个动态语言。除此之外如Ruby、Python等也都属于动态语言，而C、C++等语言则不属于动态语言。(引自: 百度百科) 概念主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。 反射是java中一种强大的工具，能够使我们很方便的创建灵活的代码，这些代码可以再运行时装配，无需在组件之间进行源代码链接。但是反射使用不当会成本很高！ 通俗说就是 1.可以于运行时加载,探知和使用编译期间完全未知的类 2.程序在运行状态中, 可以动态加载一个只有名称的类, 对于任意一个已经加载的类,都能够知道这个类的所有属性和方法; 对于任意一个对象,都能调用他的任意一个方法和属性 3.加载完类之后, 在堆内存中会产生一个Class类型的对象(一个类只有一个Class对象), 这个对象包含了完整的类的结构信息,而且这个Class对象就像一面镜子,透过这个镜子看到类的结构,所以被称之为:反射。 使用的类通过查询api可以发现使用了四个类，分别对应类的本身，类的构造方法，类的方法，类的属性。 java.lang.Class;Class 类的实例表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，注释是一种接口。每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也表示为 Class 对象。 Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的。 获取的方式有三种： 1.对象的getClass()方法; 123456public class TestClass&#123; void printClassName(Object obj) &#123; System.out.println("The class of " + obj + " is " + obj.getClass().getName()); &#125;&#125; 2.类的.class(最安全/性能最好)属性; 123456public class TestClass&#123; void printClassName() &#123; System.out.println("The class of Object " + "is " + Object.class.getName()); &#125;&#125; 3.运用Class.forName(String className)动态加载类,className需要是类的全限定名(最常用). 123456public class TestClass&#123; void printClassName() throws ClassNotFoundException &#123; System.out.println("The class of Object " + "is" + Class.forName("java.lang.Object").getName()); &#125;&#125; 通过Class获取信息常用的有： 1.获取方法 Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 2.获取属性 Field getField(String name) 3.获取构造器 Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) 4.获取内部类 Class&lt;?&gt;[] getDeclaredClasses() 5.获取外部类 Class&lt;?&gt; getDeclaringClass() 1234567891011121314151617181920212223242526272829303132package Test;/** * Created by ly on 2017/9/12 */public class TestClass &#123; class A&#123; &#125; public static void main(String[] args) &#123; test(); test2(); &#125; static void test()&#123; Class testClass = TestClass.class; System.out.println(testClass.getName()); Class[] declaredClass = testClass.getDeclaredClasses(); for (Class c: declaredClass) &#123; System.out.println(c.getName()); &#125; &#125; static void test2()&#123; Class AClass = A.class; System.out.println(AClass); Class declaredClass = AClass.getDeclaringClass(); System.out.println(declaredClass.getName()); &#125;&#125; 运行结果： test.TestClass test.TestClass$A class test.TestClass$A test.TestClass java.lang.reflect.Method;Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息。所反映的方法可能是类方法或实例方法（包括抽象方法）。 Method 允许在匹配要调用的实参与底层方法的形参时进行扩展转换；但如果要进行收缩转换，则会抛出 IllegalArgumentException。 获取Method通过Class下的方法 1.Method getMethod(String name, Class&lt;?&gt;... parameterTypes) //返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。 name - 方法名 parameterTypes - 参数列表 2.Method[] getMethods() //返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。数组类返回从 Object 类继承的所有（公共）member 方法。返回数组中的元素没有排序，也没有任何特定的顺序。如果此 Class 对象表示没有公共成员方法的类或接口，或者表示一个基本类型或 void，则此方法返回长度为 0 的数组。 调用方法Object invoke(Object obj, Object... args) obj - 从中调用底层方法的对象 args - 用于方法调用的参数 对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。个别参数被自动解包，以便与基本形参相匹配，基本参数和引用参数都随需服从方法调用转换。 如果底层方法是静态的，那么可以忽略指定的 obj 参数。该参数可以为 null。 如果底层方法所需的形参数为 0，则所提供的 args 数组长度可以为 0 或 null。 如果底层方法是实例方法，则使用动态方法查找来调用它，这一点记录在 Java Language Specification, Second Edition 的第 15.12.4.4 节中；在发生基于目标对象的运行时类型的重写时更应该这样做。 如果底层方法是静态的，并且尚未初始化声明此方法的类，则会将其初始化。 如果方法正常完成，则将该方法返回的值返回给调用者；如果该值为基本类型，则首先适当地将其包装在对象中。但是，如果该值的类型为一组基本类型，则数组元素不 被包装在对象中；换句话说，将返回基本类型的数组。如果底层方法返回类型为 void，则该调用返回 null。 1234567public class TestClass&#123; public void test() throws IllegalAccessException, IllegalArgumentException, InvocationTargetException&#123; Class c = Object.class; Method method = c.getMethod("toString"); method.invoke(c.newInstance()); &#125;&#125; java.lang.reflect.Field;Field 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。 获取Field通过Class下的方法 1.Field getField(String name) //返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定公共成员字段。 name - 字段名 2.Field[] getFields()//返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问公共字段。返回数组中的元素没有排序，也没有任何特定的顺序。如果类或接口没有可访问的公共字段，或者表示一个数组类、一个基本类型或 void，则此方法返回长度为 0 的数组。 获取Field上的值Object get(Object obj) 返回指定对象上此 Field 表示的字段的值。如果该值是一个基本类型值，则自动将其包装在一个对象中。 底层字段的值是按以下方式获得的： 如果底层字段是一个静态字段，则忽略 obj 变量；它可能为 null。 否则，底层字段是一个实例字段。如果指定的 obj 变量为 null，则该方法将抛出一个 NullPointerException。如果指定对象不是声明底层字段的类或接口的实例，则该方法将抛出一个 IllegalArgumentException。 如果此 Field 对象强制实施 Java 语言访问控制，并且底层字段是不可访问的，则该方法将抛出一个 IllegalAccessException。如果底层字段是静态的，并且声明该字段的类尚未初始化，则初始化这个类。 否则，从底层实例字段或静态字段中获取该值。如果该字段是一个基本类型字段，则在返回前将该值包装在一个对象中，否则照原样返回。 如果字段隐藏在 obj 的类型中，则根据前面的规则获得字段的值。 java.lang.reflect.Constructor;Constructor 提供关于类的单个构造方法的信息以及对它的访问权限。 获取Constructor通过Class下的方法 1.Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) 返回一个 Constructor 对象，它反映此 Class 对象所表示的类的指定公共构造方法。parameterTypes 参数是 Class 对象的一个数组，这些 Class 对象按声明顺序标识构造方法的形参类型。 如果此 Class 对象表示非静态上下文中声明的内部类，则形参类型作为第一个参数包括显示封闭的实例。 要反映的构造方法是此 Class 对象所表示的类的公共构造方法，其形参类型与 parameterTypes 所指定的参数类型相匹配。 2.Constructor&lt;?&gt;[] getConstructors() 返回一个包含某些 Constructor 对象的数组，这些对象反映此 Class 对象所表示的类的所有公共构造方法。如果该类没有公共构造方法，或者该类是一个数组类，或者该类反映一个基本类型或 void，则返回一个长度为 0 的数组。 注意，此方法返回 Constructor 对象的数组（即取自此类构造方法的数组）时，此方法的返回类型是 Constructor&lt;?&gt;[]，不是 预期的 Constructor[]。此少量信息的返回类型是必需的，因为从此方法返回之后，该数组可能被修改以保存不同类的 Constructor 对象，而这将违反 Constructor[] 的类型保证。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC 配置及常用注解]]></title>
    <url>%2F2017%2F09%2F10%2FSpring%20MVC%20%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Spring MVC 作为目前最主流的MVC框架之一，需要程序员熟练掌握。 而使用注解可以大大简化配置的流程，减少工作量。 所以这里简单讲解Spring MVC注解的配置和常用注解。 配置jar包引入 使用Gradle compile ‘org.springframework:spring-context:4.2.5.RELEASE’ compile ‘org.springframework:spring-webmvc:4.2.5.RELEASE’ web.xml配置 SpringMVC是一个基于DispatcherServlet的MVC框架，每一个请求最先访问的都是DispatcherServlet，DispatcherServlet负责转发每一个Request请求给相应的Handler，Handler处理以后再返回相应的视图(View)和模型(Model)，返回的视图和模型都可以不指定，即可以只返回Model或只返回View或都不返回。 DispatcherServlet是继承自HttpServlet的，既然SpringMVC是基于DispatcherServlet的，那么我们先来配置一下DispatcherServlet，好让它能够管理我们希望它管理的内容。HttpServlet是在web.xml文件中声明的。 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;!-- 指定Spring Bean的配置文件所在目录 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:context.xml&lt;/param-value&gt; &lt;!-- 默认是/WEB-INF/applicationContext.xml --&gt; &lt;/context-param&gt; &lt;!-- Spring配置 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- spring mvc配置 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:mvc.xml&lt;/param-value&gt; &lt;!-- 默认是/WEB-INF/[servlet名字]-servlet.xml --&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; ContextLoaderListener指定了IOC容器初始化的方法 Spring MVC配置 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:util="http://www.springframework.org/schema/util" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 启用spring mvc 注解 --&gt; &lt;context:annotation-config /&gt; &lt;!-- 设置使用注解的类所在的jar包 --&gt; &lt;context:component-scan base-package="controller"/&gt; &lt;!-- 对转向页面的路径解析。prefix：前缀， suffix：后缀 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" p:prefix="/jsp/" p:suffix=".jsp" /&gt;&lt;/beans&gt; 使用注解 对你的Controller类使用@Controller注解进行标记。 常用注解@Controller 在SpringMVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在SpringMVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。 @Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是SpringMVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式： 在SpringMVC 的配置文件中定义MyController 的bean 对象。 在SpringMVC 的配置文件中告诉Spring 该到哪里去找标记为@Controller 的Controller 控制器。 1234&lt;!--方式一--&gt;&lt;bean class="com.host.app.web.controller.MyController"/&gt;&lt;!--方式二--&gt;&lt; context:component-scan base-package = "com.host.app.web" /&gt;//路径写到controller的上一层(扫描包详解见下面浅析) @RequestMapping RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 RequestMapping注解有六个属性。 value : 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）; method : 指定请求的method类型， GET、POST、PUT、DELETE等; consumes : 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html; produces : 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回; params : 指定request中必须包含某些参数值是，才让该方法处理。 headers : 指定request中必须包含某些指定的header值，才能让该方法处理请求。 使用 @RequestMapping 来映射 Request 请求与处理器 方式一、通过常见的类路径和方法路径结合访问controller方法 方式二、使用url模板 123456789101112@Controller@RequestMapping ( "/test/&#123;variable1&#125;" )public class MyController &#123; @RequestMapping ( "/showView/&#123;variable2&#125;" ) public ModelAndView showView( @PathVariable("variable1") String variable1, @PathVariable ("variable2") int variable2) &#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName( "viewName" ); modelAndView.addObject( " 需要放到 model 中的属性名称 " , " 对应的属性值，它是一个对象 " ); return modelAndView; &#125;&#125; URI 模板就是在 URI 中给定一个变量，然后在映射的时候动态的给该变量赋值。如URI 模板http://localhost/app/{variable1}/index.html ，这个模板里面包含一个变量variable1 ，那么当我们请求http://localhost/app/hello/index.html 的时候，该URL 就跟模板相匹配，只是把模板中的variable1 用hello 来取代。这个变量在SpringMVC 中是使用@PathVariable 来标记的。在SpringMVC 中，我们可以使用@PathVariable 来标记一个Controller 的处理方法参数，表示该参数的值将使用URI 模板中对应的变量的值来赋值。 代码中我们定义了两个URI 变量，一个是控制器类上的variable1 ，一个是showView 方法上的variable2 ，然后在showView 方法的参数里面使用@PathVariable 标记使用了这两个变量。所以当我们使用/test/hello/showView/2.do 来请求的时候就可以访问到MyController 的showView 方法，这个时候variable1 就被赋予值hello ，variable2 就被赋予值2 ，然后我们在showView 方法参数里面标注了参数variable1 和variable2 是来自访问路径的path 变量，这样方法参数variable1 和variable2 就被分别赋予hello 和2 。方法参数variable1 是定义为String 类型，variable2 是定义为int 类型，像这种简单类型在进行赋值的时候Spring 是会帮我们自动转换的。 在上面的代码中我们可以看到在标记variable1 为path 变量的时候我们使用的是@PathVariable ，而在标记variable2 的时候使用的是@PathVariable(“variable2”) 。这两者有什么区别呢？第一种情况就默认去URI 模板中找跟参数名相同的变量，但是这种情况只有在使用debug 模式进行编译的时候才可以，而第二种情况是明确规定使用的就是URI 模板中的variable2 变量。当不是使用debug 模式进行编译，或者是所需要使用的变量名跟参数名不相同的时候，就要使用第二种方式明确指出使用的是URI 模板中的哪个变量。 除了在请求路径中使用URI 模板，定义变量之外，@RequestMapping 中还支持通配符“* ”。如下面的代码我就可以使用/myTest/whatever/wildcard.do 访问到Controller 的testWildcard 方法。 123456789@Controller@RequestMapping ( "/myTest" )public class MyController &#123; @RequestMapping ( "*/wildcard" ) public String testWildcard() &#123; System. out .println( "wildcard------------" ); return "wildcard" ; &#125; &#125; params属性12345@RequestMapping (value= "testParams" , params=&#123; "param1=value1" , "param2" , "!param3" &#125;)public String testParams() &#123; System. out .println( "test Params..........." ); return "testParams" ;&#125; 用@RequestMapping 的params 属性指定了三个参数，这些参数都是针对请求参数而言的，它们分别表示参数param1 的值必须等于value1 ，参数param2 必须存在，值无所谓，参数param3 必须不存在，只有当请求/testParams.do 并且满足指定的三个参数条件的时候才能访问到该方法。所以当请求/testParams.do?param1=value1&amp;param2=value2 的时候能够正确访问到该testParams 方法，当请求/testParams.do?param1=value1&amp;param2=value2&amp;param3=value3 的时候就不能够正常的访问到该方法，因为在@RequestMapping 的params 参数里面指定了参数param3 是不能存在的。 method属性1234@RequestMapping (value= "testMethod" , method=&#123;RequestMethod. GET , RequestMethod. DELETE &#125;)public String testMethod() &#123; return "method" ;&#125; 在上面的代码中就使用method 参数限制了以GET 或DELETE 方法请求/testMethod 的时候才能访问到该Controller 的testMethod 方法。 headers属性1234@RequestMapping (value= "testHeaders" , headers=&#123; "host=localhost" , "Accept" &#125;)public String testHeaders() &#123; return "headers" ;&#125; headers 属性的用法和功能与params 属性相似。在上面的代码中当请求/testHeaders.do 的时候只有当请求头包含Accept 信息，且请求的host 为localhost 的时候才能正确的访问到testHeaders 方法。 @RequestMapping 标记的处理器方法支持的方法参数和返回类型 1.支持的方法参数类型 （1）HttpServlet 对象，主要包括HttpServletRequest 、HttpServletResponse 和HttpSession 对象。 这些参数Spring 在调用处理器方法的时候会自动给它们赋值，所以当在处理器方法中需要使用到这些对象的时候，可以直接在方法上给定一个方法参数的申明，然后在方法体里面直接用就可以了。但是有一点需要注意的是在使用HttpSession 对象的时候，如果此时HttpSession 对象还没有建立起来的话就会有问题。 （2）Spring 自己的WebRequest 对象。 使用该对象可以访问到存放在HttpServletRequest 和HttpSession 中的属性值。 （3）InputStream 、OutputStream 、Reader 和Writer 。 InputStream 和Reader 是针对HttpServletRequest 而言的，可以从里面取数据；OutputStream 和Writer 是针对HttpServletResponse 而言的，可以往里面写数据。 （4）使用@PathVariable 、@RequestParam 、@CookieValue 和@RequestHeader 标记的参数。 （5）使用@ModelAttribute 标记的参数。 （6）java.util.Map 、Spring 封装的Model 和ModelMap 。 这些都可以用来封装模型数据，用来给视图做展示。 （7）实体类。 可以用来接收上传的参数。 （8）Spring 封装的MultipartFile 。 用来接收上传文件的。 （9）Spring 封装的Errors 和BindingResult 对象。 这两个对象参数必须紧接在需要验证的实体对象参数之后，它里面包含了实体对象的验证结果。 2.支持的返回类型 （1）一个包含模型和视图的ModelAndView 对象。 （2）一个模型对象，这主要包括Spring 封装好的Model 和ModelMap ，以及java.util.Map ，当没有视图返回的时候视图名称将由RequestToViewNameTranslator 来决定。 （3）一个View 对象。这个时候如果在渲染视图的过程中模型的话就可以给处理器方法定义一个模型参数，然后在方法体里面往模型中添加值。 （4）一个String 字符串。这往往代表的是一个视图名称。这个时候如果需要在渲染视图的过程中需要模型的话就可以给处理器方法一个模型参数，然后在方法体里面往模型中添加值就可以了。 （5）返回值是void 。这种情况一般是我们直接把返回结果写到HttpServletResponse 中了，如果没有写的话，那么Spring 将会利用RequestToViewNameTranslator 来返回一个对应的视图名称。如果视图中需要模型的话，处理方法与返回字符串的情况相同。 （6）如果处理器方法被注解@ResponseBody 标记的话，那么处理器方法的任何返回类型都会通过HttpMessageConverters 转换之后写到HttpServletResponse 中，而不会像上面的那些情况一样当做视图或者模型来处理。 （7）除以上几种情况之外的其他任何返回类型都会被当做模型中的一个属性来处理，而返回的视图还是由RequestToViewNameTranslator 来决定，添加到模型中的属性名称可以在该方法上用@ModelAttribute(“attributeName”) 来定义，否则将使用返回类型的类名称的首字母小写形式来表示。使用@ModelAttribute 标记的方法会在@RequestMapping 标记的方法执行之前执行。 @Resource 和 @Autowired @Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。 共同点 两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。 不同点 (1) @Autowired @Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。 12345678910public class TestServiceImpl &#123; // 下面两种@Autowired只要使用一种即可 @Autowired private UserDao userDao; // 用于字段上 @Autowired public void setUserDao(UserDao userDao) &#123; // 用于属性的方法上 this.userDao = userDao; &#125;&#125; @Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。如下： 12345public class TestServiceImpl &#123; @Autowired @Qualifier("userDao") private UserDao userDao; &#125; (2) @Resource @Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。 12345678910public class TestServiceImpl &#123; // 下面两种@Resource只要使用一种即可 @Resource(name="userDao") private UserDao userDao; // 用于字段上 @Resource(name="userDao") public void setUserDao(UserDao userDao) &#123; // 用于属性的setter方法上 this.userDao = userDao; &#125;&#125; 注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。 @Resource装配顺序： ①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。 ②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。 ③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。 ④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。 @Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。 @ModelAttribute 和 @SessionAttributes 该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。 @SessionAttributes即将值放到session作用域中，写在class上面。 @SessionAttributes @SessionAttributes: 该注解用来绑定HttpSession中的attribute对象的值，便于在方法中的参数里使用。 该注解有value、types两个属性，可以通过名字和类型指定要使用的attribute 对象； 123456@Controller @RequestMapping("/editPet.do") @SessionAttributes("pet") public class EditPetForm &#123; // ... &#125; 2.@ModelAttribute 该注解有两个用法，一个是用于方法上，一个是用于参数上； 用于方法上时： 通常用来在处理@RequestMapping之前，为请求绑定需要从后台查询的model； 用于参数上时： 用来通过名称对应，把相应名称的值绑定到注解的参数bean上；要绑定的值来源于： A） @SessionAttributes 启用的attribute 对象上； B） @ModelAttribute 用于方法上时指定的model对象； C） 上述两种情况都没有时，new一个需要绑定的bean对象，然后把request中按名称对应的方式把值绑定到bean中。 用到方法上1234@ModelAttribute public Account addAccount(@RequestParam String number) &#123; return accountManager.findAccount(number); &#125; 这种方式实际的效果就是在调用@RequestMapping的方法之前，为request对象的model里put（“account”， Account）。 用在参数上1234@RequestMapping(value="/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit", method = RequestMethod.POST) public String processSubmit(@ModelAttribute Pet pet) &#123; &#125; 首先查询 @SessionAttributes有无绑定的Pet对象，若没有则查询@ModelAttribute方法层面上是否绑定了Pet对象，若没有则将URI template中的值按对应的名称绑定到Pet对象的各属性上。 3.使用 @ModelAttribute 和 @SessionAttributes 传递和保存数据 当 @ModelAttribute 标记在方法上的时候，该方法将在处理器方法执行之前执行，然后把返回的对象存放在 session 或模型属性中，属性名称可以使用 @ModelAttribute(“attributeName”) 在标记方法的时候指定，若未指定，则使用返回类型的类名称（首字母小写）作为属性名称。关于 @ModelAttribute 标记在方法上时对应的属性是存放在 session 中还是存放在模型中，我们来做一个实验，看下面一段代码。 12345678910111213141516171819202122232425262728293031@Controller@RequestMapping ( "/myTest" )public class MyController &#123; @ModelAttribute ( "hello" ) public String getModel() &#123; System. out .println( "-------------Hello---------" ); return "world" ; &#125; @ModelAttribute ( "intValue" ) public int getInteger() &#123; System. out .println( "-------------intValue---------------" ); return 10; &#125; @RequestMapping ( "sayHello" ) public void sayHello( @ModelAttribute ( "hello" ) String hello, @ModelAttribute ( "intValue" ) int num, @ModelAttribute ( "user2" ) User user, Writer writer, HttpSession session) throws IOException &#123; writer.write( "Hello " + hello + " , Hello " + user.getUsername() + num); writer.write( "\r" ); Enumeration enume = session.getAttributeNames(); while (enume.hasMoreElements()) writer.write(enume.nextElement() + "\r" ); &#125; @ModelAttribute ( "user2" ) public User getUser()&#123; System. out .println( "---------getUser-------------" ); return new User(3, "user2" ); &#125;&#125; 当我们请求 /myTest/sayHello.do 的时候使用 @ModelAttribute 标记的方法会先执行，然后把它们返回的对象存放到模型中。最终访问到 sayHello 方法的时候，使用 @ModelAttribute 标记的方法参数都能被正确的注入值。执行结果如下所示： Hello world,Hello user210 由执行结果我们可以看出来，此时 session 中没有包含任何属性，也就是说上面的那些对象都是存放在模型属性中，而不是存放在 session 属性中。那要如何才能存放在 session 属性中呢？这个时候我们先引入一个新的概念 @SessionAttributes ，它的用法会在讲完 @ModelAttribute 之后介绍，这里我们就先拿来用一下。我们在 MyController 类上加上 @SessionAttributes 属性标记哪些是需要存放到 session 中的。看下面的代码： 1234567891011121314151617181920212223242526272829303132333435@Controller@RequestMapping ( "/myTest" )@SessionAttributes (value=&#123; "intValue" , "stringValue" &#125;, types=&#123;User. class &#125;)public class MyController &#123; @ModelAttribute ( "hello" ) public String getModel() &#123; System. out .println( "-------------Hello---------" ); return "world" ; &#125; @ModelAttribute ( "intValue" ) public int getInteger() &#123; System. out .println( "-------------intValue---------------" ); return 10; &#125; @RequestMapping ( "sayHello" ) public void sayHello(Map&lt;String, Object&gt; map, @ModelAttribute ( "hello" ) String hello, @ModelAttribute ( "intValue" ) int num, @ModelAttribute ( "user2" ) User user, Writer writer, HttpServletRequest request) throws IOException &#123; map.put( "stringValue" , "String" ); writer.write( "Hello " + hello + " , Hello " + user.getUsername() + num); writer.write( "\r" ); HttpSession session = request.getSession(); Enumeration enume = session.getAttributeNames(); while (enume.hasMoreElements()) writer.write(enume.nextElement() + "\r" ); System. out .println(session); &#125; @ModelAttribute ( "user2" ) public User getUser() &#123; System. out .println( "---------getUser-------------" ); return new User(3, "user2" ); &#125;&#125; 在上面代码中我们指定了属性为 intValue 或 stringValue 或者类型为 User 的都会放到 Session中，利用上面的代码当我们访问 /myTest/sayHello.do 的时候，结果如下： Hello world,Hello user210 仍然没有打印出任何 session 属性，这是怎么回事呢？怎么定义了把模型中属性名为 intValue 的对象和类型为 User 的对象存到 session 中，而实际上没有加进去呢？难道我们错啦？我们当然没有错，只是在第一次访问 /myTest/sayHello.do 的时候 @SessionAttributes 定义了需要存放到 session 中的属性，而且这个模型中也有对应的属性，但是这个时候还没有加到 session 中，所以 session 中不会有任何属性，等处理器方法执行完成后 Spring 才会把模型中对应的属性添加到 session 中。所以当请求第二次的时候就会出现如下结果： Hello world,Hello user210 user2 intValue stringValue 当 @ModelAttribute 标记在处理器方法参数上的时候，表示该参数的值将从模型或者 Session 中取对应名称的属性值，该名称可以通过 @ModelAttribute(“attributeName”) 来指定，若未指定，则使用参数类型的类名称（首字母小写）作为属性名称。 @PathVariable 用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出url模板中的变量作为参数。若方法参数名称和需要绑定的uri template中变量名称不一致，需要在@PathVariable(“name”)指定uri template中的名称。 123456789101112131415161718192021@Controller public class TestController &#123; @RequestMapping(value="/user/&#123;userId&#125;/roles/&#123;roleId&#125;",method = RequestMethod.GET) public String getLogin(@PathVariable("userId") String userId, @PathVariable("roleId") String roleId)&#123; System.out.println("User Id : " + userId); System.out.println("Role Id : " + roleId); return "hello"; &#125; @RequestMapping(value="/product/&#123;productId&#125;",method = RequestMethod.GET) public String getProduct(@PathVariable("productId") String productId)&#123; System.out.println("Product Id : " + productId); return "hello"; &#125; @RequestMapping(value="/javabeat/&#123;regexp1:[a-z-]+&#125;", method = RequestMethod.GET) public String getRegExp(@PathVariable("regexp1") String regexp1)&#123; System.out.println("URI Part 1 : " + regexp1); return "hello"; &#125; &#125; @RequestParam @RequestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(“name”)，它有三个常用参数：defaultValue = “0”, required = false, value = “isApp”；defaultValue 表示设置默认值，required 通过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。 A）常用来处理简单类型的绑定，通过Request.getParameter() 获取的String可直接转换为简单类型的情况（ String–&gt; 简单类型的转换操作由ConversionService配置的转换器来完成）；因为使用request.getParameter()方式获取参数，所以可以处理get 方式中queryString的值，也可以处理post方式中 body data的值； B）用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容，提交方式GET、POST； 1234567891011@Controller @RequestMapping("/pets") @SessionAttributes("pet") public class EditPetForm &#123; @RequestMapping(method = RequestMethod.GET) public String setupForm(@RequestParam("petId") int petId, ModelMap model) &#123; Pet pet = this.clinic.loadPet(petId); model.addAttribute("pet", pet); return "petForm"; &#125;&#125; @RequestBody 该注解常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等； 它是通过使用 HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。 因为配置有FormHttpMessageConverter，所以也可以用来处理 application/x-www-form-urlencoded的内容，处理完的结果放在一个MultiValueMap里，这种情况在某些特殊需求下使用，详情查看FormHttpMessageConverter api; 1234@RequestMapping(value = "/something", method = RequestMethod.PUT) public void handle(@RequestBody String body, Writer writer) throws IOException &#123; writer.write(body); &#125; @ResponseBody 作用：该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。 使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用； @RequestHeader @RequestHeader 注解，可以把Request请求header部分的值绑定到方法的参数上。 123456789101112131415/*这是一个Request 的header部分：Host localhost:8080 Accept text/html,application/xhtml+xml,application/xml;q=0.9 Accept-Language fr,en-gb;q=0.7,en;q=0.3 Accept-Encoding gzip,deflate Accept-Charset ISO-8859-1,utf-8;q=0.7,*;q=0.7 Keep-Alive 300*/@RequestMapping("/displayHeaderInfo.do") public void displayHeaderInfo(@RequestHeader("Accept-Encoding") String encoding, @RequestHeader("Keep-Alive") long keepAlive) &#123; &#125; 上面的代码，把request header部分的 Accept-Encoding的值，绑定到参数encoding上了， Keep-Alive header的值绑定到参数keepAlive上。 @CookieValue @CookieValue 可以把Request header中关于cookie的值绑定到方法的参数上。 例如有如下Cookie值： JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84123@RequestMapping("/displayHeaderInfo.do") public void displayHeaderInfo(@CookieValue("JSESSIONID") String cookie) &#123; &#125; 即把JSESSIONID的值绑定到参数cookie上。 @Component 相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。 @Repository 用于注解dao层，在daoImpl类上面注解。 &lt; context:component-scan base-package = “” /&gt;浅析 component-scan 默认扫描的注解类型是 @Component，不过，在 @Component 语义基础上细化后的 @Repository, @Service 和 @Controller 也同样可以获得 component-scan 的青睐 有了&lt;context:component-scan&gt;，另一个&lt;context:annotation-config/&gt;标签根本可以移除掉，因为已经被包含进去了 另外&lt;context:annotation-config/&gt;还提供了两个子标签 1.&lt;context:include-filter&gt; //指定扫描的路径 2.&lt;context:exclude-filter&gt; //排除扫描的路径 &lt;context:component-scan&gt; 有一个use-default-filters属性，属性默认为true,表示会扫描指定包下的全部的标有@Component的类，并注册成bean.也就是@Component的子注解@Service,@Repository等。 这种扫描的粒度有点太大，如果你只想扫描指定包下面的Controller或其他内容则设置use-default-filters属性为false，表示不再按照scan指定的包扫描，而是按照&lt;context:include-filter&gt;指定的包扫描，示例： 123&lt;context:component-scan base-package="com.tan" use-default-filters="false"&gt; &lt;context:include-filter type="regex" expression="com.tan.*"/&gt;//注意后面要写.*&lt;/context:component-scan&gt; 当没有设置use-default-filters属性或者属性为true时，表示基于base-package包下指定扫描的具体路径 12345&lt;context:component-scan base-package="com.tan" &gt; &lt;context:include-filter type="regex" expression=".controller.*"/&gt; &lt;context:include-filter type="regex" expression=".service.*"/&gt; &lt;context:include-filter type="regex" expression=".dao.*"/&gt;&lt;/context:component-scan&gt; 效果相当于： 123&lt;context:component-scan base-package="com.tan" &gt; &lt;context:exclude-filter type="regex" expression=".model.*"/&gt;&lt;/context:component-scan&gt;]]></content>
      <categories>
        <category>Spring MVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 注解]]></title>
    <url>%2F2017%2F09%2F10%2FJava%20%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解是java引入的一项非常受欢迎的补充，它提供了一种结构化的，并且具有类型检查能力的新途径，从而使得程序员能够为代码加入元数据，而不会导致代码杂乱且难以阅读。使用注解能够帮助我们避免编写累赘的部署描述文件，以及其他生成的文件。 注解的语法比较简单，除了@符号的使用之外，它基本与java固有的语法一致。但由于java源码中提供的内置注解很少，所以大部分同学对注解都不是很了解，虽然我们都接触过，比如java内置的几种注解： @Override，表示当前的方法定义将覆盖超类中的方法。 @Deprecated，表示当前方法即将废弃，不推荐使用。 @SuppressWarnings，表示忽略编译器的警告信息。 要深入学习注解，我们就必须能定义自己的注解，并使用注解，在定义自己的注解之前，我们就必须要了解Java为我们提供的元注解和相关定义注解的语法。 元注解元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解： 1.@Target 2.@Retention 3.@Documented 4.@Inherited 这些类型和它们所支持的类在java.lang.annotation包中可以找到。下面我们看一下每个元注解的作用和相应分参数的使用说明。 @Target@Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。 作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方） 取值(ElementType)有： 1.CONSTRUCTOR:用于描述构造器 2.FIELD:用于描述域 3.LOCAL_VARIABLE:用于描述局部变量 4.METHOD:用于描述方法 5.PACKAGE:用于描述包 6.PARAMETER:用于描述参数 7.TYPE:用于描述类、接口(包括注解类型) 或enum声明 123456789@Target(ElementType.TYPE)public @interface Table &#123; public String tableName() default "className"&#123;&#125;@Target(ElementType.FIELD) public @interface NoDBColumn &#123;&#125; 注解Table 可以用于注解类、接口(包括注解类型) 或enum声明,而注解NoDBColumn仅可用于注解类的成员变量。 @Retention@Retention定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。 作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效） 取值（RetentionPolicy）有： 1.SOURCE:在源文件中有效（即源文件保留） 2.CLASS:在class文件中有效（即class保留） 3.RUNTIME:在运行时有效（即运行时保留） Retention meta-annotation类型有唯一的value作为成员，它的取值来自java.lang.annotation.RetentionPolicy的枚举类型值。 12345678@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface Column &#123; public String name() default "fieldName"; public String setFuncName() default "setField"; public String getFuncName() default "getField"; public boolean defaultDBValue() default false;&#125; Column注解的的RetentionPolicy的属性值是RUTIME,这样注解处理器可以通过反射，获取到该注解的属性值，从而去做一些运行时的逻辑处理 @Documented@Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。 123456789@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Column &#123; public String name() default "fieldName"; public String setFuncName() default "setField"; public String getFuncName() default "getField"; public boolean defaultDBValue() default false;&#125; @Inherited@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。 注意：@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。 当@Inherited annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强了这种继承性。如果我们使用java.lang.reflect去查询一个@Inherited annotation类型的annotation时，反射代码检查将展开工作：检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。 123456@Inheritedpublic @interface Greeting &#123; public enum FontColor&#123; BLUE,RED,GREEN&#125;; String name(); FontColor fontColor() default FontColor.GREEN;&#125; 自定义注解使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。 定义注解格式： public @interface 注解名 {定义体} 注解参数的可支持数据类型： 1.所有基本数据类型（int,float,boolean,byte,double,char,long,short) 2.String类型 3.Class类型 4.enum类型 5.Annotation类型 6.以上所有类型的数组 Annotation类型里面的参数该怎么设定: 第一,只能用public或默认(default)这两个访问权修饰.例如,String value();这里把方法设为default默认类型； 第二,参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数成员就为String; 第三,如果只有一个参数成员,最好把参数名称设为”value”,后加小括号. 12345678910/*** 自定义注解*/@Target(ElementType.TYPE)@Documented@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation &#123; String value() default "";&#125; 注解元素的默认值： 注解元素必须有确定的值，要么在定义注解的默认值中指定，要么在使用注解时指定，非基本类型的注解元素的值不可为null。因此, 使用空字符串或0作为默认值是一种常用的做法。这个约束使得处理器很难表现一个元素的存在或缺失的状态，因为每个注解的声明中，所有元素都存在，并且都具有相应的值，为了绕开这个约束，我们只能定义一些特殊的值，例如空字符串或者负数，一次表示某个元素不存在，在定义注解时，这已经成为一个习惯用法。 注解处理注解类使用上了，我们还需要一个注解处理器来解析我们定义的Bean，这样才能将注解转换成我们需要的操作。 Java使用Annotation接口来代表程序元素前面的注解，该接口是所有Annotation类型的父接口。除此之外，Java在java.lang.reflect 包下新增了AnnotatedElement接口，该接口代表程序中可以接受注解的程序元素，该接口主要有如下几个实现类： Class：类定义 Constructor：构造器定义 Field：类的成员变量定义 Method：类的方法定义 Package：类的包定义 java.lang.reflect 包下主要包含一些实现反射功能的工具类，实际上，java.lang.reflect 包所有提供的反射API扩充了读取运行时Annotation信息的能力。当一个Annotation类型被定义为运行时的Annotation后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。 AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的如下四个个方法来访问Annotation信息： &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass): 返回改程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。 Annotation[] getAnnotations():返回该程序元素上存在的所有注解。 boolean is AnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass):判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false. Annotation[] getDeclaredAnnotations()：返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注解。（如果没有注解直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。 123456789101112public class TestAnnotation &#123; public static void main(String[] args) &#123; MyAnnotation annotation = annotation.class.getAnnotation(MyAnnotation.class); System.out.println(annotation.value()); &#125; &#125;@MyAnnotation(value = "123")class annotation &#123;&#125; 以上是通过反射获取annotation类的注解，并打印注解中value的值]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2017%2F09%2F05%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[记录一些Git命令 专用名词： Workspace: 工作区 Index/ Stage: 暂存区 Repository: 仓库区（本地仓库） Remote: 远程仓库 图解 新建代码库$ git init # 在当前目录新建一个git代码库 $ git init [project-name] # 新建一个目录，将其初始化为Git仓库 $ git clone [url] # 下载一个项目和它的整个代码历史 配置Git 的设置文件为.gitconfig, 它可以在用户主目录下（全局配置）， 也可以在项目目录下（项目配置）。 $ git config --list # 显示当前的Git配置 $ git config -e [--global] # 编辑Git配置文件 $ git config [--global] user.name &quot;[name]&quot; $ git config [--global] user.email &quot;[email address]&quot; # 设置提交代码时的用户信息 增加/删除文件$ git add [file1] [file2] ... # 添加指定文件到暂存区 $ git add [dir] # 添加指定目录到暂存区，包括子目录 $ git add . # 添加当前目录所有文件到暂存区 $ git add -p # 添加每个变化前，都会要求确认。 对于同一个文件的多处变化，可以多次提交 $ git rm [file1] [file2] # 删除工作区文件，并且将这次删除放入暂存区 $ git rm --cached [file] # 停止追踪指定文件，但该文件会保留在工作区 $ git mv [file-original] [file-renamed] # 改名文件，并且将这个改名放入暂存区 代码提交$ git commit -m [message] # 提交暂存区到仓库区 $ git commit [file1] [file2] -m [message] # 提交暂存区的指定文件到仓库区 $ git commit -a # 提交工作区自上次 commit 之后的变化，直接到仓库区 $ git commit -v # 提交时显示所有的 diff 信息 $ git commit -amend -m [message] # 使用一次新的 commit ，替代上一次提交。如果代码没有任何新变化，则用来改写上一次 commit 的提交信息 $ git commit -amend [file1] [file2] ... # 重做上一次 commit ，并包括指定文件的新变化 分支$ git branch # 列出所有本地分支 $ git branch -r # 列出所有远程分支 $ git branch -a # 列出所有本地分支和远程分支 $ git branch [branch-name] # 新建一个分支，但依然停留在当前分支 $ git branch -b [branch] # 新建一个分支，并切换到该分支 $ git branch [branch] [commit] # 新建一个分支，指向指定commit $ git branch --track [branch] [remote-branch] # 新建一个分支，与指定的远程分支建立追踪关系 $ git checkout [branch-name] # 切换到指定分支，并更新工作区 $ git checkout - # 切换到上一个分支 $ git merge [branch] # 合并指定分支到当前分支 $ git cherry-pick [commit] # 选择一个commit，合并进当前分支 $ git branch -d [branch-name] # 删除分支 $ git push origin -delete [branch-name] $ git branch -dr [remote/branch] # 删除远程分支 标签$ git tag # 列出所有tag $ git tag [tag] # 新建一个tag在当前commit $ git tag [tag] [commit] # 新建一个tag在指定commit $ git tag -d [tag] # 删除本地tag $ git push origin :refs/tags/[tagName] # 删除远程tag $ git show [tag] # 查看tag信息 $ git push [remote] [tag] # 提交指定tag $ git push [remote] --tags # 提交所有tag $ git checkout -b [branch] [tag] # 新建一个分支，指向某个tag 查看信息$ git status # 显示有变更的文件 $ git log # 显示当前分支的版本历史 $ git log --stat # 显示commit历史，以及每次commit发生变更的文件 $ git log -S [keyword] # 搜索提交历史，根据关键词 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --grep feature # 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件 $ git log --follow [file] $ git whatchange [file] # 显示某个文件的版本历史，包括文件改名 $ git log -p [file] # 显示指定文件相关的每一次diff $ git log -5 --pretty --oneline # 显示过去5次提交 $ git shortlog -sn # 显示所有提交过的用户，按提交次数排序 $ git blame [file] # 显示指定文件是什么人在什么时间修改过 $ git diff # 显示暂存区和工作区的差异 $ git diff --cached [file] # 显示暂存区和上一个commit的差异 $ git diff HEAD # 显示工作区与当前分支最新commit之间的差异 $ git diff [first-branch]...[second-branch] # 显示两次提交之间的差异 $ git diff --shortstat &quot;@{0 day ago}&quot; # 显示今天你写了多少行代码 $ git show [commit] # 显示某次提交的元数据和内容变化 $ git show --name-only [commit] # 显示某次提交发生变化的文件 $ git show [commit]:[filename] # 显示某次提交时，某个文件的内容 $ git reflog # 显示当前分支的最近几次提交 远程同步$ git fetch [remote] # 下载远程仓库的所有变动 $ git remote -v # 显示所有远程仓库 $ git remote show [remote] # 显示某个远程仓库的信息 $ git remote add [shortname] [url] # 增加一个新的远程仓库，并命名 $ git pull [remote] [branch] # 取回远程仓库的变化，并与本地分支合并 $ git push [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] --force # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --all # 推送所有分支到远程仓库 撤销$ git checkout [file] # 恢复暂存区的指定文件到工作区 $ git checkout [commit] [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout . # 恢复暂存区的所有文件到工作区 $ git reset [file] # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset --hard # 重置暂存区与工作区，与上一次commit保持一致 $ git reset [commit] # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset --hard [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --keep [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git revert [commit] # 新建一个commit，用来撤销指定commit。后者的所有变化都将被前者抵消，并且应用到当前分支。 $ git stash $ git stash pop # 暂时将未提交的变化移除，稍后再移入 其他$ git archive # 生成一个可供发布的压缩包]]></content>
      <categories>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用命令笔记]]></title>
    <url>%2F2017%2F06%2F30%2Fhexo%2F</url>
    <content type="text"><![CDATA[hexonpm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写hexo n &quot;我的博客&quot; == hexo new “我的博客” #新建文章 hexo p == hexo publish hexo g == hexo generate #生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy #部署 服务器` hexo server` #Hexo 会监视文件变动并自动更新，您无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单 hexo generate --watch #监视文件变动 完成后部署两个命令的作用是相同的 hexo generate --deploy hexo deploy --generate hexo deploy -ghexo server -g 草稿hexo publish [layout] &lt;title&gt; 模板hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub hexo new [layout] &lt;title&gt; hexo new photo &quot;My Gallery&quot; hexo new &quot;Hello World&quot; --lang tw 设置文章摘要以上是文章摘要 &lt;!--more--&gt; 以下是余下全文 写作hexo new page &lt;title&gt; hexo new post &lt;title&gt; ###推送到服务器上 hexo n #写文章 hexo g #生成 hexo d #部署 #可与hexo g合并为 hexo d -g]]></content>
      <categories>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个问题]]></title>
    <url>%2F2017%2F06%2F29%2FSecond%2F</url>
    <content type="text"><![CDATA[部署博客后的第一个问题第一次通过 hexo + github 部署博客，并且绑定了个人域名。 但是在每次部署之后使用个人域名访问博客，就会出现 404 界面。 今天在搞定主题之后，直接上传就关了电脑，结果用手机访问博客时发现出现 404 界面。 爬起来开机去 github 的仓库中看了之后发现 在 setting 绑定的域名失效了，又变成了 github 的二级域名 解决方法在百度了之后，绑定域名后DNS解析一定要修改，需要添加记录类型为 CNAME 的解析记录，其中记录值为 yourname.github.io CNAME 是将自己的域名指向你的 github 域名 同时，在本地的 source 文件夹里创建 CNAME 文件 （注意：是CNAME 不是CHAME） 不带任何后缀 里面添加你的域名信息，如： xanxus.xin 不能含有 www 或者 http：// 然后hexo d -g]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>侃侃</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First]]></title>
    <url>%2F2017%2F06%2F29%2FFirst%2F</url>
    <content type="text"><![CDATA[第一篇文章从今天开始，咱也是有博客的人了，虽然目前能力低，没有什么有价值的文章哈哈哈哈哈哈哈哈哈哈哈 这个博客主要用来记录平时学习的心得体会，遇到的问题以及解决办法 虽然目前遇到的问题很简单，网上很容易找到答案。。。。。。。。 呃。。。。 也没啥要说的，希望这个博客能陪我到毕业甚至工作，也希望这个博客中能记录更多有价值的内容。]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>侃侃</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FirstTest]]></title>
    <url>%2F2017%2F06%2F29%2FFirstTest%2F</url>
    <content type="text"><![CDATA[这是一篇测试用文章 第一次测试 第一次使用hexo搭建博客 #测试 这是一篇测试用文章 第一次测试 第一次使用hexo搭建博客 首次目标，上传至github，并成功。]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
